package eu.modernmt.processing.string;

import eu.modernmt.model.Sentence;
import eu.modernmt.model.Tag;
import eu.modernmt.model.Token;
import eu.modernmt.model.Word;

import java.util.*;

/**
 * Created by andrea on 22/02/17.
 * <p>
 * A SentenceBuilder handles the whole tokenization of a string
 * and generates a Sentence object with the resulting Tokens.
 * <p>
 * The SentenceBuilder stores both
 * - the original version of the String, which is never altered
 * - the current version of the String, that can require changes
 * In order to perform String processing the SentenceBuilder generates Editors,
 * that are initialized with the current version of the String
 * and can update it by creating and committing Transformations.
 * <p>
 * The SentenceBuilder also has a Transformation list
 * that all Editors add their Transformations to executing commit.
 * <p>
 * Moreover, the SentenceBuilder has a reference to a IndexMap object
 * that for each position i on the local version of the string in the current Editor
 * contains the position on the correspondent character on the original string.
 * <p>
 * During the execution of the build() method the SentenceBuilder
 * uses Transformations to create Tokens, that are employed to generate a Sentence.
 */
public class SentenceBuilder {

    /*original string to tokenize*/
    private String originalString;
    /*the string as it appears after the changes of the last commit*/
    private String currentString;
    /*ordered list that stores, for each editor,
    the ordered list of the Transformations it performs*/
    private List<List<Transformation>> sentenceBuilderTransformations;
    /*indexMap is an object that for each position in the current editor local string
    * stores the corresponding position in the original string*/
    private IndexMap indexMap;

    /**
     * Constructor that generates a SentenceBuilder for a given string.
     *
     * @param string the original string that must be processed and tokenized
     */
    public SentenceBuilder(String string) {
        this.originalString = string;
        /*at the beginning no transformations have been performed*/
        this.currentString = string;
        /*list of transformation lists generated by editors*/
        this.sentenceBuilderTransformations = new ArrayList<>();
        /*initialize indexMap array that maps each position of the current string
        * to a position in the original string*/
        this.indexMap = new IndexMap(originalString.length() + 1);
    }

    /**
     * Method that creates a new Editor to process the current string version.
     *
     * @return the newly created editor
     */
    public Editor edit() {
        return new Editor();
    }

    /**
     * Method that scans all transformations
     * in all Transformation lists generated by the various editors;
     * it selects the non-in-conflict transformations with highest proprity,
     * uses them to generate tokens (words and tags)
     * and finally uses them to create a Sentence object
     *
     * @return the Sentence resulting from the transformations on the original string
     */
    public Sentence build() {

        /*List of the highest priority transformation that do not overlap
        * and can therefore be all used to generate tokens*/
        List<Transformation> tokenizableTransformations = this.getTokenizableTransformations();

        /*Lists of words and tags generated by the tokenizable transformations*/
        TokenSet tokenSet = this.tokenize(tokenizableTransformations);
        List<Token> words = tokenSet.WORDS;
        List<Token> tags = tokenSet.TAGS;

        /*build the Sentence based on the words and tags lists */
        Sentence sentence = new Sentence(words.toArray(new Word[words.size()]), tags.toArray(new Tag[tags.size()]));
        return sentence;
    }


    /**
     * Method that scans all the Transformation lists generated by the various editors,
     * and selects the tokenizable Transformations;
     * in case of conflict between two or more Transformations,
     * the Transformations with lower priority are filtered out.
     * The resulting Transformation list is finally sorted by increasing position
     * <p>
     * Note: replacements are here considered as non tokenizable Transformations
     *
     * @return the list of high-priority, non overlapping transformations,
     * sorted by their start position on the original string
     */
    private List<Transformation> getTokenizableTransformations() {

        /*Create a bitset with as many bits as the positions in originalString
        * the bitset is employed to remember, for each position in the original string,
        * whether the corresponding character has been altered by a transformation or not*/
        BitSet bitset = new BitSet(this.originalString.length());

        /*List of priority, non overlapping tokenizable transformations extracted so far
        * from the SentenceBuilder list of transformation lists*/
        List<Transformation> tokenizableTransformations = new ArrayList<Transformation>();

        /*Scan the list of transformation lists from the last to the first,
        * and each list from the last transformation to the first one;*/
        for (int i = this.sentenceBuilderTransformations.size() - 1;
             i >= 0;
             i--) {

            List<Transformation> currentEditorTransformations = this.sentenceBuilderTransformations.get(i);

            for (int j = currentEditorTransformations.size() - 1;
                 j >= 0;
                 j--) {

                Transformation t = currentEditorTransformations.get(j);
                boolean tokenizable = true;

                /* For each Transformation, first check if it has a token factory; if not,
                (e.g. it is a replacement), it is not tokenizable and it will be skipped*/
                if (t.TOKEN_FACTORY == null)
                    tokenizable = false;

                /*then, check if the transformation is in conflict with already visited ones;
                * it is in conflict if some of its positions in the bitset have already
                * been set to true by other transformations (that have thus higher priority)
                * If this happens, the transformation is not tokenizable*/
                for (int h = t.START; h < t.END && tokenizable; h++) {
                    tokenizable = tokenizable && !bitset.get(h);
                }

                /*finally, if the current transformation is still considered tokenizable,
                it is added to the ordered list of tokenizable transformations*/
                if (tokenizable) {
                    for (int h = t.START; h < t.END; h++) {
                        bitset.set(h, true);
                    }
                    tokenizableTransformations.add(t);
                }
            }
        }

        /*the tokenizable Transformation list is finally sorted by increasing start position*/
        Collections.sort(tokenizableTransformations,
                new Comparator<Transformation>() {
                    @Override
                    public int compare(Transformation o1, Transformation o2) {
                        return o1.START - o2.START;
                    }
                });
        return tokenizableTransformations;
    }


    /**
     * Method that scans over all the tokenizable Transformations and
     * generates a Token object for each of them.
     *
     * @param transformations the list of all tokenizable Transformations,
     *                        sorted by increasing start position
     * @return a TokenSet containing a separate list of Tokens
     * for each Token type generated (e.g. words, tags, etc).
     */
    private TokenSet tokenize(List<Transformation> transformations) {

        List<Token> words = new ArrayList<>();
        List<Token> tags = new ArrayList<>();

        /*Create a token for each position in the tokenizableTransformation list*/
        for (int i = 0; i < transformations.size(); i++) {

            Transformation transformation = transformations.get(i);

            /*extract the necessary information from the current transformation*/
            String text = transformation.TEXT;
            TokenFactory tokenFactory = transformation.TOKEN_FACTORY;

            /*compute additional information about the way that
             the current transformation is linked to the previous and next ones in the list*/

            /*there is a space between previous transformation text and current one*/
            boolean hasLeftSpace;
            /*there is a space between previous transformation text and next one*/
            boolean hasRightSpace;
            /*string with the space between current transformation text and next one*/
            String rightSpace = null;
            /*amount of WORDS that occur before the current transformation*/
            int tagPosition;

            /*compute hasLeftSpace*/
            /*if the current transformation is the first one in the list*/
            if (i == 0) {
                hasLeftSpace = (transformation.START != 0);
            /*if the current transformation is not the first one in the list*/
            } else {
                Transformation previousTransformation = transformations.get(i - 1);
                hasLeftSpace = (transformation.START - previousTransformation.END != 0);
            }

            /*compute hasRightSpace and rightSpace*/
            /*if the current transformation is the last one in the list*/
            if (i == transformations.size() - 1) {
                hasRightSpace = (transformation.END != this.originalString.length());
                if (hasRightSpace) {
                    rightSpace = this.originalString.substring(transformation.END, this.originalString.length());
                }
            /*if the current transformation is not the last one in the list*/
            } else {
                Transformation nextTransformation = transformations.get(i + 1);
                hasRightSpace = (transformation.END != nextTransformation.START);

                if (hasRightSpace) {
                    rightSpace = this.originalString.substring(transformation.END, nextTransformation.START);
                }
            }

            /*compute tagPosition*/
            /*the current tag position is the amount of words in the */
            tagPosition = words.size();

            /*generate the Token*/
            Token token = tokenFactory.build(text, hasLeftSpace, rightSpace, tagPosition);

            /*put the token in the separate list corresponding to its class*/
            if (token instanceof Tag) {
                tags.add(token);
            } else if (token instanceof Word) {
                words.add(token);
            }
        }

        /*create and return a new tokenset with the various token lists obtained*/
        return new TokenSet(words, tags);
    }



    /*getters and setters*/

    public String getOriginalString() {
        return this.originalString;
    }

    public String getCurrentString() {
        return this.currentString;
    }

    @Override
    public String toString() {
        return this.currentString;
    }


    public static void main(String[] args) throws Throwable {
        String text = "<b>Ciao </b>amico &apos;mio&apos;<br/>`apos strano  \t` {0,<b>ciao<b/>}.<br/>";
        text = "<b>Ciao </b>amico &apos;mio;`apos strano \t {0,<b>ciao<b/>}.<br/>";

        SentenceBuilder builder = new SentenceBuilder(text);
        Editor editor;
        String currentString;

        // XMessage
        currentString = builder.toString();
        System.out.println("XMessage: " + currentString);

        editor = builder.edit();
        editor.setToken(currentString.indexOf("{0,<b>ciao<b/>}"), "{0,<b>ciao<b/>}".length(), " ", TokenFactory.TAG_FACTORY);
        editor.commit();

        // XML stripper
        currentString = builder.toString();
        System.out.println("XML stripper: " + currentString);

        editor = builder.edit();
        editor.setTag(currentString.indexOf("<b>"), 3, "tagbold");
        editor.setTag(currentString.indexOf("</b>"), 4, "tagbold");


        editor.setReplacement(currentString.indexOf("&apos;"), 6, "'");
        //editor.replace(currentString.indexOf("&apos;"), 6, "'");
        editor.setTag(currentString.indexOf("<br/>"), 5, " ");
        //editor.setTag(currentString.indexOf("<br/>"), 5, " ");
        editor.commit();

        // RareCharsNormalizer
        currentString = builder.toString();
        System.out.println("RareCharsNormalizer: " + currentString);

        editor = builder.edit();
        editor.setReplacement(currentString.indexOf("`"), 1, "'");
        //editor.replace(currentString.indexOf("`"), 1, "'");
        editor.commit();

        // WordTokenizer
        currentString = builder.toString();
        System.out.println("WordTokenizer: " + currentString);

        editor = builder.edit();
        editor.setWord(currentString.indexOf("Ciao"), "Ciao".length(), null);
        editor.setWord(currentString.indexOf("amico"), "amico".length(), null);


        /*dice che questo è lungo 9*/

        editor.setWord(currentString.indexOf("'"), "'".length(), null);


        editor.setWord(currentString.indexOf("mio"), "mio".length(), null);

        editor.setWord(currentString.indexOf("'"), "'".length(), null);


        editor.setWord(currentString.indexOf("'"), "'".length(), null);
        editor.setWord(currentString.indexOf("apos"), "apos".length(), null);
        editor.setWord(currentString.indexOf("strano"), "strano".length(), null);

        editor.setWord(currentString.indexOf("'"), "'".length(), null);
        editor.setWord(currentString.indexOf("."), ".".length(), null);
        editor.commit();

        // WTF WordTokenizer
        currentString = builder.toString();
        System.out.println("WTF WordTokenizer: " + currentString);

        editor = builder.edit();
        editor.setWord(currentString.indexOf("'apos"), "'apos".length(), null);
        editor.commit();

        // Compiling
        System.out.println("  Original string: " + builder.getOriginalString());
        System.out.println("   Current string: " + builder);

        System.out.println("\n \n \n \n");
        //System.out.println("<b>Ciao </b>amico &apos;mio;`apos strano  \t {0,<b>ciao<b/>}.<br/>");
        text = "<b>Ciao </b>amico &apos;mio;`apos strano \t {0,<b>ciao<b/>}.<br/>";

        Sentence sentence = builder.build();


        System.out.println("         Sentence: " + sentence);
        System.out.println("Stripped sentence: " + sentence.getStrippedString(true));
    }


    /**
     * An Editor is an object that scans the current version of the string
     * in order to perform processing activities
     * and creates a Transformation object for each of them.
     * <p>
     * Transformations include:
     * - simple replacement of character sequences
     * - detection of special characters / words / tags (with or without replacement)
     * <p>
     * The Editor stores the Transformation in a local list, and
     * works on the String to edit by updating a local version.
     * <p>
     * When an Editor performs a processing activity, it is given
     * the start and end indexes of the text to edit
     * in relation to the current version of the String stored in the SentenceBuilder.
     * <p>
     * Such indexes may be inconsistent to both the original version of the string
     * and its version local to the current Editor,
     * because other Editors and/or the current one may have already performed replacements,
     * thus altering the positions of the characters.
     * <p>
     * As a consequence The Editor
     * - uses an offset field representing the shift between the character positions
     * in the current version in the Stringbuilder and local version in the Editor itself;
     * - updates the SentenceBuilder IndexMap object after each replacement, so that
     * it keeps the correspondence between local version and original version
     * <p>
     * After an editing session is over, the Editor executes its commit() method:
     * all its Transformations are sent to the SentenceBuilder transformations list,
     * and the SentenceBuilder currentString is updated to the current Editor local version.
     * <p>
     */
    public class Editor {
        List<Transformation> localTransformations;

        /*Local string version.
         * It is initialized as identical to the SentenceBuilder current string.
         * In all its processing activities the editor updates the local version.
         * During commit the SentenceBuilder current string is overwritten with localString.*/
        StringBuilder localString;

        /* offset between the local version and the SentenceBuilder current version */
        int offset;

        /**
         * Constructor that initializes an Editor for the current SentenceBuilder
         * using the SentenceBuilder current version of the String.
         */
        public Editor() {
            /*the local version of the string is initially identical to the current one
            * (except it must allow updates, so it is a StringBuilder object)*/
            this.localString = new StringBuilder(currentString);
            /*The list of transformations generated by this editor*/
            this.localTransformations = new ArrayList<>();
            /*the offset between the positions in the local version of the string
             and their counterparts in its current version*/
            this.offset = 0;
        }

        /**
         * This method creates a Transformation and substitutes with replacement
         * the portion of current String between start and start+length.
         * The newly created Transformation object is then added to the
         * local editor Transformation list.
         *
         * @param currentStart first position of the text to edit in the current string
         * @param length       length of the text to edit
         * @param replacement  string that must substitute the text to edit.
         *                     If no replacement is needed, this parameter is null.
         * @param factory:     object that can generate tokens; depending on the kind of transformation
         *                     it can be specialized for words, tags, etc.
         *                     If no token must be generated by this transformation, this parameter is null.
         */
        public void setTransformation(int currentStart, int length, String replacement, TokenFactory factory) {

            int currentEnd = currentStart + length;
            String text = currentString.substring(currentStart, currentEnd);

            /*use the offset to calculate start and end in the original String*/
            int originalStart = indexMap.get(currentStart + offset);
            int originalEnd = indexMap.get(currentEnd + offset);

            /*create the transformation using the positions in the original string*/
            Transformation transformation = new Transformation(
                    originalStart,
                    originalEnd,
                    text,
                    replacement,
                    factory);

            /*update indexMap only if the transformation involves replacements*/
            if (replacement != null)
                indexMap.update(currentStart + offset, currentStart + offset + length, replacement.length());

            /*add the newly generated transformation to the local list*/
            this.localTransformations.add(transformation);
        }

        /**
         * This method performs a replacement and
         * requests the creation of the corresponding Transformation
         * (with TokenFactory field equal to null).
         *
         * @param curStartIndex first position of the text to edit in the current string.
         * @param textLength    length of the text to process.
         * @param replacement   string that must substitute the text to edit.
         */
        public void setReplacement(int curStartIndex, int textLength, String replacement) {
            /*create the Transformation, put it in the Editor Transformations list
             * and update the positions array*/
            setTransformation(curStartIndex, textLength, replacement, null);
            /*Update the currentString and the offset*/
            this.replace(curStartIndex, textLength, replacement);
        }

        /**
         * This method requests the creation of a Transformation
         * passing it specific parameters to create a Token during the sentence build;
         * if a replacement is requested, it is performed.
         *
         * @param startIndex  first position of the text to edit in the current string
         * @param textLength  length of the text to edit
         * @param replacement string that must substitute the text to edit.
         * @param factory     object that can be employed to create Tokens
         */
        public void setToken(int startIndex, int textLength, String replacement, TokenFactory factory) {
            /*create the Transformation, put it in the Editor Transformations list
             * and update the positions array*/
            setTransformation(startIndex, textLength, replacement, factory);
            /*update the local version of the String, if needed*/
            if (replacement != null)
                this.replace(startIndex, textLength, replacement);
        }

        /**
         * This method requests the creation of a Token
         * passing it specific parameters to create a Word during the sentence build
         *
         * @param startIndex  first position of the text to edit in the current string
         * @param length      length of the text to edit
         * @param replacement string that must substitute the text to edit.
         */
        public void setWord(int startIndex, int length, String replacement) {
            /*create the Transformation, put it in the Editor Transformations list
             * update the positions array and if necessary perform replacement;
             * as a TokenFactory use a WORD_FACTORY*/
            this.setToken(startIndex, length, replacement, TokenFactory.WORD_FACTORY);
        }

        /**
         * This method requests the creation of a Token
         * passing it specific parameters to create a Word during the sentence build
         *
         * @param startIndex  first position of the text to edit in the current string
         * @param length      length of the text to edit
         * @param replacement string that must substitute the text to edit.
         */
        public void setTag(int startIndex, int length, String replacement) {
            /*create the Transformation, put it in the Editor Transformations list
             * update the positions array and if necessary perform replacement;
             * as a TokenFactory use a TAG_FACTORY*/
            this.setToken(startIndex, length, replacement, TokenFactory.TAG_FACTORY);
        }

        /**
         * This method ends this Editor's scan on the current version of the String.
         * The Editor sends all its transformation to the SentenceBuilder,
         * updates the SentenceBuilder current string with its own local version,
         * and finally prepares for new scan.
         */
        public void commit() {
            /*add this Editor's transformation list to the SentenceBuilder Transformation lists*/
            sentenceBuilderTransformations.add(this.localTransformations);
            /*update the SentenceBuilder current string with this Editor's local string*/
            currentString = this.localString.toString();

            /*make the editor ready to start over*/
            localTransformations = new ArrayList<>();
            this.offset = 0;

        }

        /**
         * This method performs replaces a portion of the Editor local version of the string
         * and, contextually, updates the Editor offset.
         * It is always called during the execution of setReplacement method
         * and it may be called during the execution of the setToken method.
         *
         * @param startIndex  the first position of the string portion to replace
         * @param textLength  the length of the string portion to replace
         * @param replacement the string to put in place of the old text
         */
        private void replace(int startIndex, int textLength, String replacement) {

            /*if the replace method is called, replacement must be valid*/
            if (replacement == null)
                throw new NullPointerException("replacement");

            /* update the local version of the String*/
            this.localString.replace(
                    startIndex + offset,
                    startIndex + offset + textLength,
                    replacement);

            /*update the offset*/
            this.offset = this.offset - textLength + replacement.length();
        }
    }
}