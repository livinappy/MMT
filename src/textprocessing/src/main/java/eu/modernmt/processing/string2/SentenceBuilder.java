package eu.modernmt.processing.string2;

import eu.modernmt.model.Sentence;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by andrea on 22/02/17.
 *
 * A SentenceBuilder takes care of the processing phases that string undergo
 * in order to perform tokenization and obtain a final Sentence object.
 *
 * The SentenceBuilder stores both
 * - the original version of the String, which is never changed
 * - the current version of the String, that can require changes
 *   (and is therefore implemented as a StringBuilder object).
 *
 * Moreover, a SentenceBuilder contains a positions array
 * that for each position i on the current string
 * contains the position on the correspondent character on the original string;
 * positions therefore represents the mapping between current and original string.
 * and must be updated after any Editor executes
 * any kind of update (e.g. replacement) on current string
 *
 * Starting from the original string, the SentenceBuilder
 * allows the creation of Editors that can be requested
 * many kinds of string Transformations (tag setting, word setting, replacement, etc).
 *
 * The SentenceBuilder also has a transformation list
 * all Editors add their transformations to when they execute commit().
 *
 * During the execution of the build() method
 * each transformation can lead to a separate Token
 * (unless it is a simple replacement);
 * the set of all generated Tokens is finally employed
 * to produce the Sentence object.
 */
public class SentenceBuilder {

    /*original string to tokenize*/
    private String originalString;

    /*the string as it appears after the last editor activity*/
    private String currentString;

    /*array that for each position in the current string
    * stores the correspondant position in the original string*/
    private int[] positions;

    /*ordered list that stores, for each editor,
    the ordered list of the Transformations it performs*/
    private List<List<Transformation>> sentenceBuilderTransformations;

    /*IndexMap for the positions array management*/
    private IndexMap indexMap;

    /** Constructor that generates a SentenceBuilder for a given string.*/
    public SentenceBuilder(String string) {
        this.originalString = string;
        /*at the beginning no transformations have been performed*/
        this.currentString = string;
        /*list of transformation lists generated by editors*/
        this.sentenceBuilderTransformations = new ArrayList<>();
        /*array that maps each position of the current string
        * to a position in the original string*/
        this.positions = new int[originalString.length()+1];
        /*initialize positions*/
        for (int i = 0; i <= originalString.length(); i++) {
            positions[i] = i;
        }
        /*initialize indexMap for positions*/
        this.indexMap = new IndexMap(this.positions);
    }

    /** Method that creates a new editor to process the current string version.*/
    public Editor edit() {
        return new Editor();
    }

    /** Method that scans all transformations in all transformation lists
     * and employs them to generate tokens*/

    public Sentence build() {
        /*fa costruire tutte le transformation di cui ha ricette*/
        /*sovrascrive la propria currentTransformedString?*/
        for (List<Transformation> singleEditorList : this.sentenceBuilderTransformations) {
            for (Transformation transformation :  singleEditorList) {
                System.out.println(transformation.toString());
                System.out.println("   Original: " + this.originalString.substring(transformation.getStart(), transformation.getEnd()));
                System.out.println();
            }
        }
        return null;
    }


    /*getters and setters*/

    public String getOriginalString() {
        return this.originalString;
    }

    public String getCurrentString() {
        return this.currentString;
    }


    @Override
    public String toString() {
        return this.currentString;
    }


    public static void main(String[] args) throws Throwable {
        String text = "<b>Ciao </b>amico &apos;mio&apos;<br/>`apos strano  \t` {0,<b>ciao<b/>}.<br/>";
        text = "<b>Ciao </b>amico &apos;mio;`apos strano \t {0,<b>ciao<b/>}.<br/>";

        SentenceBuilder builder = new SentenceBuilder(text);
        Editor editor;
        String currentString;

        // XMessage
        currentString = builder.toString();
        System.out.println("XMessage: " + currentString);

        editor = builder.edit();
        editor.setToken(currentString.indexOf("{0,<b>ciao<b/>}"), "{0,<b>ciao<b/>}".length(), " ", null);
        editor.commit();

        // XML stripper
        currentString = builder.toString();
        System.out.println("XML stripper: " + currentString);

        editor = builder.edit();
        editor.setTag(currentString.indexOf("<b>"), 3, "tagbold");
        editor.setTag(currentString.indexOf("</b>"), 4, "tagbold");


        editor.setReplacement(currentString.indexOf("&apos;"), 6, "'");
        //editor.replace(currentString.indexOf("&apos;"), 6, "'");
        editor.setTag(currentString.indexOf("<br/>"), 5, " ");
        //editor.setTag(currentString.indexOf("<br/>"), 5, " ");
        editor.commit();

        // RareCharsNormalizer
        currentString = builder.toString();
        System.out.println("RareCharsNormalizer: " + currentString);

        editor = builder.edit();
        editor.setReplacement(currentString.indexOf("`"), 1, "'");
        //editor.replace(currentString.indexOf("`"), 1, "'");
        editor.commit();

        // WordTokenizer
        currentString = builder.toString();
        System.out.println("WordTokenizer: " + currentString);

        editor = builder.edit();
        editor.setWord(currentString.indexOf("Ciao"), "Ciao".length(), null);
        editor.setWord(currentString.indexOf("amico"), "amico".length(), null);


        /*dice che questo è lungo 9*/

        editor.setWord(currentString.indexOf("'"), "'".length(), null);


        editor.setWord(currentString.indexOf("mio"), "mio".length(), null);

        editor.setWord(currentString.indexOf("'"), "'".length(), null);



        editor.setWord(currentString.indexOf("'"), "'".length(), null);
        editor.setWord(currentString.indexOf("apos"), "apos".length(), null);
        editor.setWord(currentString.indexOf("strano"), "strano".length(), null);

        editor.setWord(currentString.indexOf("'"), "'".length(), null);
        editor.setWord(currentString.indexOf("."), ".".length(), null);
        editor.commit();

        // WTF WordTokenizer
        currentString = builder.toString();
        System.out.println("WTF WordTokenizer: " + currentString);

        editor = builder.edit();
        editor.setWord(currentString.indexOf("'apos"), "'apos".length(), null);
        editor.commit();

        // Compiling
        System.out.println("  Original string: " + builder.getOriginalString());
        System.out.println("   Current string: " + builder);

        System.out.println("\n \n \n \n");
        System.out.println("<b>Ciao </b>amico &apos;mio;`apos strano  \t {0,<b>ciao<b/>}.<br/>");
        Sentence sentence = builder.build();

        //System.out.println("         Sentence: " + sentence);
        //System.out.println("Stripped sentence: " + sentence.getStrippedString(true));
    }







    /**
     * An Editor is an object that scans the current version of the string
     * in order to perform processing activities.
     * Each processing activity leads to the generation of a Transformation object.
     *
     * Transformations include:
     *      - simple replacement of character sequences
     *      - detection of special characters / words / tags (with or without replacement)
     *
     * When an Editor is requested the creation of a Transformation,
     * it is given the start and end indexes of the involved text in the currentString
     * kept in the SentenceBuilder.
     *
     * Such indexes may not be consistent to the original version of the string,
     * because any Editing session (including the current one) may have performed replacements.
     **
     * Therefore the Editor employs and updates an offset
     * that represents the shift produced during its very session
     * between the positions in the current string and the Editor local version.
     *
     * At the same time it makes use of the positions array in the SentenceBuilder,
     * that contains the information about the shift between
     * original string and current string.
     *
     *
     * Transformations are not executed at the moment of their creation,
     * but are put in a list that the editor commits to its SentenceBuilder.
     * Transformations are executed only when the SentenceBuilder executes its "build" method.
     *
     * After an editing session is over, the Editor executes its commit() method
     * that updates the SentenceBuilder currentString with the local version of the Editor
     * and adds all its transformation to the SentenceBuilder list.
     */
    public class Editor {
        List<Transformation> localTransformations;

        /*Local string version.
         * It starts as exactly identical to the current string version of the SentenceBuilder.
         * All processing activities that the editor performs are done on the local version.
         * In the end, during commit(), the SentenceBuilder current string is overwritten with localString.*/

        /*ha senso perché da fuori la currentString quando si decide
         * quali trasformazioni si vogliono richiedere agli editor
         * viene vista solo all'inizio (dopo l'ultimo commit).
         * */
        StringBuilder localString;

        /* offset between the local string version
         * and the current string version kept in the SentenceBuilder*/
        int offset;



        public Editor() {
            this.localString = new StringBuilder(currentString);
            this.localTransformations = new ArrayList<>();
            this.offset = 0;
        }


        /**
         * This method creates a Transformation
         * and replaces the text that the current String contains between start and start+length
         * with replacement.
         * The newly created Transformation object is then added to the
         * local editor Transformation list.
         *
         * @param currentStart starting index in the current string
         * @param length length of the text to process
         * @param replacement string that must replace the text to process. If no replacement is needed, this parameter is null.
         * @param factory: object that can generate tokens; depending on the kind of transformation
         *                 it can be specialized for words, tags, etc.
         *                  If no token must be generated by this transformation, this parameter is null.
         */
        public void setTransformation(int currentStart, int length, String replacement, TokenFactory factory) {

            /*the actual start index may be changed due to previous transformations
            * that this same editor may have executed before this one, in the same session*/
            //int transformationStartIndex = startIndex - this.offset;
            //int transformationEndIndex = startIndex - this.offset + length;


            int currentEnd = currentStart + length;
            String text = currentString.substring(currentStart, currentEnd);


            int originalStart = positions[currentStart + offset];
            int originalEnd = positions [currentEnd + offset];

            /*create the transformation*/
            Transformation transformation = new Transformation(
                    originalStart,
                    originalEnd,
                    text,
                    replacement,
                    factory);

            /*AGGIORNA POSITIONS solo se ci sono dei replacement*/
            if (replacement != null)
                indexMap.updateArray(currentStart + offset, currentStart + offset + length, replacement.length());

            /*add the newly generated transformation to the local list*/
            this.localTransformations.add(transformation);
        }


        /**
         * This method performs a replacement and
         * requests the creation of the corresponding Transformation
         *
         * @param curStartIndex starting index in the current string.
         * @param textLength length of the text to process.
         * @param replacement string that must replace the text to process. It must be not null.
         */
        public void setReplacement(int curStartIndex, int textLength, String replacement) {

            if(replacement == null) {
                throw new NullPointerException("replacement");
            }

            /*create the transformation AND update the positions array*/
            setTransformation(curStartIndex, textLength, replacement, null);


            /*Update the currentString */
            this.localString.replace(
                    curStartIndex + offset,
                    curStartIndex + offset + textLength,
                    replacement);


            /*update the offset*/
            this.offset = this.offset-textLength+replacement.length();
        }


        public void setToken(int startIndex, int textLength, String replacement, TokenFactory factory) {

            setTransformation(startIndex, textLength, replacement, factory);

            /*If the setToken involves replacements, update the editedString
            * (else, it must not be changed) */
            if (replacement != null) {
                this.localString.replace(
                        startIndex + offset,
                        startIndex + offset + textLength,
                        replacement);


                /*update the offset*/
                this.offset = this.offset - textLength + replacement.length();
            }
        }

        public void setWord(int startIndex, int length, String replacement) {

            this.setToken(startIndex, length, replacement, TokenFactory.WORD_FACTORY);

        }

        public void setTag(int startIndex, int length, String replacement) {

            this.setToken(startIndex, length, replacement, TokenFactory.TAG_FACTORY);
        }


        /**
         *
         */
        public void commit() {
            /*add the transformation list generated by this editor
            * to the overall list of transformation lists in the SentenceBuilder*/
            sentenceBuilderTransformations.add(this.localTransformations);


            /*aggiorna l'array*/
            for (Transformation transformation : this.localTransformations) {
                if (transformation.getReplacement() != null) {
                    //currentPos2originalPos = new IndexMap(0, null).updateArray(currentPos2originalPos, transformation);
                }
            }

            currentString = this.localString.toString();
            /*"pulisci" la lista senza svuotare la vecchia*/
            localTransformations = new ArrayList<>();
            this.offset = 0;

        }
    }
}            /*QUESTO CALCOLO E' CORRETTO? SEMBRA DI SI*/
